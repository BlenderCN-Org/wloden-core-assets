import shaderSignature;
import environment;
import fragment;
import terrainMaterial;
import lighting;

function fetchAlbedoPlane(texcoord: float2, splatting: float4) -> float4
{
    using MaterialState;

    let a0 = albedoSampler.sample(albedoTexture0, texcoord*textureScales[0] + textureOffsets[0]);
    let a1 = albedoSampler.sample(albedoTexture1, texcoord*textureScales[1] + textureOffsets[1]);
    let a2 = albedoSampler.sample(albedoTexture2, texcoord*textureScales[2] + textureOffsets[2]);
    let a3 = albedoSampler.sample(albedoTexture3, texcoord*textureScales[3] + textureOffsets[3]);
    let a4 = albedoSampler.sample(albedoTexture4, texcoord*textureScales[4] + textureOffsets[4]);

    return mixSplatting(a0, a1, a2, a3, a4, splatting);
}

function mixTriplanar(normal: float3, vx: float4, vy: float4, vz: float4) -> float4
{
    let blending = fabs(normal);
    blending = blending / (blending.x + blending.y + blending.z);

    return vx*blending.x + vy*blending.y + vz*blending.z;
}

function mixTriplanarNormal(normal: float3, vx: float4, vy: float4, vz: float4) -> float4
{
    let blending = normalize(fabs(normal));

    return vx*blending.x + vy*blending.y + vz*blending.z;
}

function fetchAlbedo(objectPosition: float3, normal: float3, splatting: float4) -> float4
{
    let vx = fetchAlbedoPlane(objectPosition.yz, splatting);
    let vy = fetchAlbedoPlane(objectPosition.zx, splatting);
    let vz = fetchAlbedoPlane(objectPosition.xy, splatting);

    return mixTriplanar(normal, vx, vy, vz);
}

function fetchNormalPlane(texcoord: float2, splatting: float4) -> float4
{
    using MaterialState;

    let n0 = normalSampler.sample(normalTexture0, texcoord*textureScales[0] + textureOffsets[0]);
    let n1 = normalSampler.sample(normalTexture1, texcoord*textureScales[1] + textureOffsets[1]);
    let n2 = normalSampler.sample(normalTexture2, texcoord*textureScales[2] + textureOffsets[2]);
    let n3 = normalSampler.sample(normalTexture3, texcoord*textureScales[3] + textureOffsets[3]);
    let n4 = normalSampler.sample(normalTexture4, texcoord*textureScales[4] + textureOffsets[4]);

    return mixSplatting(n0, n1, n2, n3, n4, splatting)*float4(2.0f, 2.0f, 2.0f, 1.0f) - float4(1.0f, 1.0f, 1.0f, 0.0f);
}

function fetchNormalPlaneYZ(texcoord: float2, splatting: float4, objectNormalSigns: float3) -> float4
{
    let normal = fetchNormalPlane(texcoord, splatting);
    return float4(normal.zxy*objectNormalSigns, normal.a);
}

function fetchNormalPlaneZX(texcoord: float2, splatting: float4, objectNormalSigns: float3) -> float4
{
    let normal = fetchNormalPlane(texcoord, splatting);
    return float4(normal.yzx*objectNormalSigns, normal.a);
}

function fetchNormalPlaneXY(texcoord: float2, splatting: float4, objectNormalSigns: float3) -> float4
{
    let normal = fetchNormalPlane(texcoord, splatting);
    return float4(normal.xyz*objectNormalSigns, normal.a);
}

function fetchNormal(objectPosition: float3, normal: float3, splatting: float4) -> float4
{
    let normalSigns = sign(normal);
    let vx = fetchNormalPlaneYZ(objectPosition.yz, splatting, normalSigns);
    let vy = fetchNormalPlaneZX(objectPosition.zx, splatting, normalSigns);
    let vz = fetchNormalPlaneXY(objectPosition.xy, splatting, normalSigns);

    return mixTriplanarNormal(normal, vx, vy, vz);
}

code_block(fragment) main
{
    let dh = 0.5f*MaterialState.heightMapScale;

    let surfaceTexcoord = TerrainFragmentInput.surfaceTexcoord;
    let objectPosition = TerrainFragmentInput.objectPosition;

    if(surfaceTexcoord.s < 0.0f || surfaceTexcoord.t < 0.0f || surfaceTexcoord.s > 1.0f || surfaceTexcoord.t > 1.0f)
        discard;

    // Fetch the splatting
    let splatting = albedoSampler.sample(splattingTexture, surfaceTexcoord);

    // Compute the height map derivatives
    let dx = displacementSampler.sample(heightMapTexture, surfaceTexcoord + float2(dh.x, 0.0f)).r - displacementSampler.sample(heightMapTexture, surfaceTexcoord - float2(dh.x, 0.0f)).r;
    let dy = displacementSampler.sample(heightMapTexture, surfaceTexcoord + float2(0.0f, dh.y)).r - displacementSampler.sample(heightMapTexture, surfaceTexcoord - float2(0.0f, dh.y)).r;

    // Compute the object space normalFold this cross product.
    let ot = float3(1.0f, dx*MaterialState.heightScale, 0.0f);
    let ob = float3(0.0f, dy*MaterialState.heightScale, -1.0f);
    let on = normalize(cross(ot, ob));
    on = normalize(float3(-dx*MaterialState.heightScale, 1.0f, dy*MaterialState.heightScale));

    // Fetch the albedo.
    let rawAlbedo = fetchAlbedo(objectPosition, on, splatting);
    let albedo = TerrainFragmentInput.color*MaterialState.albedo*float4(rawAlbedo.rgb, 1.0f);

    // Fetch the actual normal
    let rawNormal = fetchNormal(objectPosition, on, splatting);
    let N = normalize(transformNormalToView(rawNormal.xyz));
    N = transformNormalToView(on);

    // Compute the smoothness and the fresnel factor.
    let fresnel = MaterialState.fresnel*rawAlbedo.a;
    let smoothness = MaterialState.smoothness*rawNormal.a;

    let V = normalize(-TerrainFragmentInput.position);

    color: FragmentOutput.color <== forwardLightingModel
        albedo: albedo
        fresnel: fresnel smoothness: smoothness
        normal: N viewVector: V position: TerrainFragmentInput.position;
    //FragmentOutput.color = float4(on*0.5f + 0.5f, 1.0f);
    //FragmentOutput.color = float4(on, 1.0f);
    //FragmentOutput.color = rawNormal;
}
