import shaderSignature;
import environment;

struct WaterHarmonic
{
    centerOrDirection: float2;
    amplitude: float;
    frequency: float;

    padding: float3;
    isRadial: int;
}

uniform(binding=MaterialState.Attributes) MaterialState
{
    albedo: float4;

    fresnel: float3;
    smoothness: float;

    padding: float3;
    propagationSpeed: float;

    harmonics: WaterHarmonic[5];
}

uniform(binding = MaterialState.Textures) normalTexture : texture2D;
uniform(binding = MaterialState.Textures + 1) skyTexture : textureCube;

function evalWaterWaves(position: float2) -> float3
{
    using CameraState;
    using MaterialState;

    // Add the harmonics.
    let height = 0.0f;
    let tangentialContributions = float2(0.0f, 0.0f);
    for(let i = 0; i < 5; i += 1)
    {
        // Fetch the harmonic parameters
        // Fetch the fields manually as a work-around for a metal bug.
        let centerOrDirection = harmonics[i].centerOrDirection;
        let amplitude = harmonics[i].amplitude;
        let frequency = harmonics[i].frequency;
        let isRadial = harmonics[i].isRadial;

        // Compute the distance factor.
        let distance : float;
        let distanceDerivatives : float2;
        if(isRadial == 1)
        {
            distance = length(position - centerOrDirection);
            distanceDerivatives = (position - centerOrDirection) / max(0.001f, distance);
        }
        else
        {
            distance = dot(position, centerOrDirection);
            distanceDerivatives = centerOrDirection;
        }

        // Compute the propagation speed factor.
        let omega = 6.283185307179586f * frequency;
        let kappa = omega / propagationSpeed;

        // Compute the contribution by the harmonic.
        let phase = kappa*distance + omega*currentTime;
        height += amplitude * sin(phase);

        // Add the tangential factor
        tangentialContributions += amplitude*kappa*cos(phase)*distanceDerivatives;
    }

    return float3(height, tangentialContributions);
}
